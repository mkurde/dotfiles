#!/usr/bin/env bash

# ------------------------------------------------------------------------------ Zettelkasten

# Create a new Zettelkasten note
function mk:zk:note:new() {
  local title="$*"
  zk new --working-dir "${ZK_NOTEBOOK_DIR}" --title="${title}"
}
# Create a new work Zettelkasten note
function mk:zk:note:work:new() {
  local title="$*"
  zk new --working-dir "${ZK_NOTEBOOK_DIR}/work" --title="${title}"
}

# Create a new Zettelkasten journal for the current month
function mk:zk:journal:new() {
  echo "todo"
  log::info "Creating a new Zettelkasten journal for the current month"
}


# ------------------------------------------------------------------------------ Kubernetes

# Start a Job of a CronJob
mk:k8s:cron () {
  kubectl create job --from=cronjob/"$1" "$1-mk-$(date -u "+%Y%m%d-%H%M%S")"
}
# Disable a CronJob
mk:k8s:cron:suspend () {
  kubectl patch cronjob "$1" -p '{"spec":{"suspend":true}}'
}
# Resume a suspended CronJob
mk:k8s:cron:resume () {
  kubectl patch cronjob "$1" -p '{"spec":{"suspend":false}}'
}

mk:k8s:restart() {
  local deployment=$1
  kubectl patch deployment ${deployment} -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"date\":\"$(date +'%s')\"}}}}}"
}

# Re-generates kubeconfigs for all Rancher clusters
function mk:k8s:kubeconfig:init() {
  readonly KUBE_CONFIG="$HOME/.kube/config"
  readonly KUBE_CONFIG_RANCHER="$HOME/.kube/rancher-config"
  local tmp_kubeconfig_path=""
  local configs_dir="$HOME/.kube/rancher.clusters"
  rm -rf "$configs_dir"
  mkdir -p "$configs_dir"
  log::info "Generating kubeconfig for Rancher clusters:"
  while read -r cluster_name cluster_id; do
    local kubeconfig_file="$configs_dir/$cluster_name.yaml"
    log::info "  - $cluster_name ($cluster_id)"
    if rancher cluster kubeconfig "$cluster_id" \
      | yq 'del(.current-context) | .contexts[0].name |= "rancher-" + .' >"$kubeconfig_file"; then
      tmp_kubeconfig_path="$kubeconfig_file:$tmp_kubeconfig_path"
    fi
  done < <(rancher cluster ls --format 'rancher-{{.Name}} {{.ID}}')

      # Backup existing kubeconfig
  if [ -f "$KUBE_CONFIG" ]; then
      log::info "Backing up existing kubeconfig at $KUBE_CONFIG"
      # Create backup file with the current date and time
      local timestamp
      timestamp=$(date +%Y%m%d-%H%M%S)
      readonly KUBE_CONFIG_BACKUP="$KUBE_CONFIG.$timestamp.bak"
    cp "$KUBE_CONFIG" "$KUBE_CONFIG_BACKUP"
    log::info "Created backup of current kubeconfig"

    # Keep only the 5 most recent backups
    local backup_count
    backup_count=$(ls -1 "$KUBE_CONFIG".*.bak 2>/dev/null | wc -l)
    if [ "$backup_count" -gt 5 ]; then
      log::info "Cleaning up old backups, keeping only 5 most recent"
      ls -1t "$KUBE_CONFIG".*.bak | tail -n +6 | xargs rm -f
    fi
  else
    log::warn "No existing kubeconfig found at $KUBE_CONFIG"
  fi

  # Merge configs
  log::info "Merging kubeconfigs..."
  if KUBECONFIG="$tmp_kubeconfig_path" kubectl config view --flatten > "$KUBE_CONFIG_RANCHER"; then
    if KUBECONFIG="$KUBE_CONFIG_RANCHER:$KUBE_CONFIG" kubectl config view --flatten > "$KUBE_CONFIG.new"; then
      mv -f "$KUBE_CONFIG.new" "$KUBE_CONFIG"
      # Ensure secure permissions (600 - only user readable/writable)
      chmod 600 "$KUBE_CONFIG"
      log::info "Set secure permissions (600) on kubeconfig"
    else
      log::error "Failed to merge kubeconfigs"
      exit 1
    fi
  else
    log::error "Failed to create Rancher kubeconfig"
    exit 1
  fi
}

# Function to close all port-forward background processes
# Call the function when done "close_port_forwards"
function mk:k8s:port:forward:close() {
  log::info "Closing all port-forward processes..."
  pkill -f "kubectl port-forward"
}

# Enhanced kres function that auto-detects deployment vs statefulset
# Overrides the oh-my-zsh kubectl plugin version with smarter resource detection
# Relies on current kubectl namespace context (run in the target namespace)
# Usage: kres <resource_name> [additional_env_vars...]
# Example: kres taktleiter
# Example: kres taktleiter DEBUG=true LOG_LEVEL=info
function mk:k8s:restart() {
  # Validate required arguments
  if [[ $# -eq 0 ]]; then
    echo "Usage: kres <resource_name> [additional_env_vars...]"
    echo "Example: kres taktleiter"
    echo "Example: kres taktleiter DEBUG=true"
    return 1
  fi

  # Parse arguments
  local resource_name="${1}"
  shift
  local additional_args="${*}"  # Concatenate remaining args as string
  local resource_type=""

  # Auto-detect resource type: deployment first, then statefulset
  # Uses current kubectl namespace context
  log::info "Checking for deployment '${resource_name}'..."
  if kubectl get deployment "${resource_name}" &>/dev/null; then
    resource_type="deployment"
    log::info "Found deployment: ${resource_name}"
  elif kubectl get statefulset "${resource_name}" &>/dev/null; then
    resource_type="statefulset"
    log::info "Found statefulset: ${resource_name}"
  else
    log::error "Error: Resource '${resource_name}' not found as deployment or statefulset"
    log::info "Searched in current namespace: $(kubectl config view --minify -o jsonpath='{..namespace}' 2>/dev/null || echo 'default')"
    return 1
  fi

  # Generate timestamp and apply environment variables
  local timestamp
  timestamp=$(date +%Y%m%d%H%M%S)
  log::info "Setting REFRESHED_AT=${timestamp} on ${resource_type}/${resource_name}"

  # Execute kubectl set env using current namespace context
  if [[ -n "${additional_args}" ]]; then
    kubectl set env "${resource_type}/${resource_name}" REFRESHED_AT="${timestamp}" ${additional_args}
  else
    kubectl set env "${resource_type}/${resource_name}" REFRESHED_AT="${timestamp}"
  fi
}


# ------------------------------------------------------------------------------ Git

# Clone a git repository
mk:git:clone() {
  if [[ $# -eq 0 ]]; then
      echo "Usage: mk:git:clone <git-url> or mk:git:clone <org/repo>"
      echo "Examples:"
      echo "  mk:git:clone git@github.com:org/foobar.git"
      echo "  mk:git:clone org/foobar"
      return 1
  fi

  local input=$1
  local url
  local repo_path

  # Check if input looks like a full URL
  if [[ "$input" =~ git@github.com: ]] || [[ "$input" =~ https://github.com/ ]]; then
      url="$input"
      # Extract path from URL
      if [[ "$url" =~ git@github.com: ]]; then
          # Remove git@github.com: prefix and .git suffix
          repo_path="github.com/$(echo "$url" | sed 's|git@github.com:||' | sed 's|\.git$||')"
      elif [[ "$url" =~ https://github.com/ ]]; then
          # Remove https://github.com/ prefix and .git suffix
          repo_path="github.com/$(echo "$url" | sed 's|https://github.com/||' | sed 's|\.git$||')"
      fi
  else
      # Assume it's org/repo format
      url="git@github.com:${input}.git"
      repo_path="github.com/${input}"
  fi

  local base_dir="$HOME/workspace/src/$repo_path"
  local target_dir="$base_dir"
  local should_clone=true

  # Check if directory already exists
  if [[ -d "$target_dir" ]]; then
      echo "Repository already exists at: $target_dir"
      echo -n "Clone again in a numbered folder? (y/n): "
      read -r response

      if [[ "$response" =~ ^[Yy]$ ]]; then
          local counter
          local repo_name
          local parent_dir
          counter=1
          repo_name=$(basename "$repo_path")
          parent_dir=$(dirname "$base_dir")

          # Find the next available number
          while [[ -d "${parent_dir}/${repo_name}_${counter}" ]]; do
              ((counter++))
          done

          target_dir="${parent_dir}/${repo_name}_${counter}"
          echo "Cloning into: $target_dir"
      else
          should_clone=false
      fi
  fi

  if [[ "$should_clone" == true ]]; then
      echo "Cloning $url into $target_dir"
      if git clone "$url" "$target_dir"; then
          echo "‚úÖ Successfully cloned!"
      else
          echo "‚ùå Failed to clone repository"
          return 1
      fi
  fi

  echo "üìÅ Switching to: $target_dir"
  cd "$target_dir" || return 1
}

# Run `gh-release` to create a GitHub release of the current remote branch, default tier "edge"
# Usage: `gh-release` or `gh-release stage` or `gh-release prod`
# Requires: GitHub CLI gh
mk:git:gh:release() {
  local repo;
  repo=$(git config --get remote.origin.url | sed -E 's/.*\:(.*)\.git/\1/g');
  echo "repo=${repo}"

  local branch;
  branch=$(git branch --show-current);
  echo "branch=${branch}"

  local tier="${1:-edge}";
  echo "tier=${tier}"

  local release;
  release=$(date -u "+%Y%m%dT%H%M%SZ-${tier}");
  echo "release=${release}"

  if [[ "${tier}" == "edge" ]] || [[ "${tier}" == "stage" ]]; then
      echo "Creating GitHub pre-release on ${tier}"
      gh release create "${release}" --prerelease --title "${release}" --generate-notes --repo "${repo}" --target "${branch}"
  else
      echo "Creating GitHub release on ${tier}"
      gh release create "${release}" --title "${release}" --generate-notes --repo "${repo}" --target "${branch}"
  fi

  echo "Find your workflow here: https://github.com/${repo}/actions"
}

# ------------------------------------------------------------------------------ Helm

# Push a Chart to ChartMuseum
mk:helm:push() {
  helm dependency update
  chart_version=$(yq '.version' Chart.yaml)
  if [[ "${1}" != "--main" ]]; then
    chart_version="${chart_version}-test${1}"
  fi
  echo "Chart version: ${chart_version}"
  helm cm-push . "${CHARTMUSEUM_REPO}" -u "${CHARTMUSEUM_BASIC_AUTH_USER}" -p "${CHARTMUSEUM_BASIC_AUTH_PASSWORD}" --version="${chart_version}"
  rm -rf charts
  rm -f Chart.lock
}

# ------------------------------------------------------------------------------ Grafana + Prometheus

# Crash the Grafana Operator pod by killing the main process
# Usage: kcrashloop_grafana_operator [--namespace <namespace>]
# Default namespace is "grafana-operator"
mk:k8s:grafana:crashloop() {
  local namespace="grafana-operator"  # Default namespace

  # Process arguments for the optional --namespace flag
  while [[ $# -gt 0 ]]; do
    case $1 in
      --namespace|-n)
        namespace=$2
        shift 2
        ;;
      *)
        echo "Usage: kcrashloop_grafana_operator [--namespace <namespace>]"
        return 1
        ;;
    esac
  done

  # Find the Grafana Operator pod
  local pod_name=$(kubectl get pods -n "$namespace" -l app.kubernetes.io/name=grafana-operator -o jsonpath='{.items[0].metadata.name}')
  if [ -z "$pod_name" ]; then
    echo "No Grafana Operator pod found in namespace ${namespace}."
    return 1
  fi

  echo "Using namespace: ${namespace}"
  echo "Target pod: ${pod_name}"

  while true; do
    kubectl exec -it -n "$namespace" "$pod_name" -- sh -c 'kill 1'
    sleep 3
  done
}
